#!/usr/bin/env bash
# Brian Chrzanowski
# 2020-09-23 10:59:17
#
# Brian's Work Script (to make kla projects managable)
#
# TODO (Brian)
# 1a. make something to symlink all (or most) config files to a single file / single directory
# 1b. make something to undo it (git probably won't like the config thing)
# 2a. make a thing to scaffold components, probably with tabs, with some sed expressions
# 2b. potentially a small interface to read sed commands + apply them
# 2c. make a small menu / selector with the shit you want in your component / module
#
# Commenting out the entire script because I don't work here anymore, but the script might still
# be useful from the MS perspective. We'll see.
# 
# DOTNETEF="dotnet-ef"
# BUILDITEMS="$HOME/.builditems"
# BUILDSTATE="$HOME/.buildstate"
# CONTAINERFILE="$HOME/.containers"
# 
# # usage
# function usage
# {
# 	echo "Brian Chrzanowski (C) $(date +"%Y")"
# 	echo ""
# 
# 	echo "workscript - The Script I Use To Get Work Done"
# 	echo ""
# 
# 	echo "USAGE: $(basename $0) <args...>"
# 	echo -e "\tpush <name>      shortcut for 'dotnet ef migrations add"
# 	echo -e "\tpop <name>       shortcut for 'dotnet ef migrations remove --force'"
# 	echo -e "\tupdate           shortcut for 'dotnet ef database update'"
# 	echo -e "\tmostrecent       shows the most recent migration in the Migrations/ directory"
# 	echo -e "\tbuildall         reads build commands from $HOME/.builditems and state from"
# 	echo -e "\t                 $HOME/.buildstate, to build a project from the root of the git repo"
# 	echo -e "\n"
# 	echo -e "\tmkcontainer <container> <tag>"
# 	echo -e "\t                 commits the current container with a new tag, and pushes it"
# 	echo -e "\n"
# 	echo -e "\tnewdb            reads $CONTAINERFILE, stops (re)starts those containers"
# 	echo -e "\tazlogin          just logs in to Azure. Fucking Microsoft."
# 	echo -e "\tindexify         creates a new typescript index file (because modules are ********)"
# 	echo -e "\treap             kills dotnet, angular, nodejs, and some other shit."
# 	echo -e "\tforktree         forks the current HEAD to a new worktree, for builds and stuff"
# 	echo ""
# 
# 	exit 1
# }
# 
# function err
# {
# 	echo "ERR: $@"
# }
# 
# function wrn
# {
# 	echo "WRN: $@"
# }
# 
# function gr
# {
# 	git rev-parse --show-toplevel
# }
# 
# # azlogin : does the azure cli login thingy
# function azlogin
# {
# 	if [ -z "$AZUSER" ] || [ -z "$AZPASS" ]; then
# 		err "you must set both \$AZUSER and \$AZPASS with your username and password respectively to login to azure" ; exit 1
# 	fi 
# 
# 	# az login -u $AZUSER -p $AZPASS
# 	az login --use-device-code
# 	az acr login --name kunzleigh
# }
# 
# # reap : reaps everything to be sown (kills all terrible, lingering processes)
# function reap
# {
# 	sudo pkill -9 dotnet
# 	sudo pkill -9 ng
# 	sudo pkill -9 node
# 	sudo pkill -9 rzls
# }
# 
# # clearstate : clears the build(s) state
# function clearstate
# {
# 	rm -f $BUILDSTATE
# 	touch $BUILDSTATE
# }
# 
# # hasstatestr : (hopefully) returns true-ish if the string is in the state file
# function hasstatestr
# {
# 	[ $(grep $1 $BUILDSTATE | wc -l) -gt 0 ] && true || false
# }
# 
# # addstatestr : adds a single string to the state
# function addstatestr
# {
# 	echo "$1" >> $BUILDSTATE
# }
# 
# # mkcontainer : makes a docker container, and pushes it up
# function mkcontainer
# {
# 	echo commit
# 	docker commit "$1" "$DOCKER_REMOTE/$1"
# 
# 	echo tag
# 	docker tag "$DOCKER_REMOTE/$1" "$DOCKER_REMOTE/$1:$2"
# 
# 	echo push
# 	docker push "$DOCKER_REMOTE/$1:$2"
# }
# 
# # buildone : a function to build a single target from buildall
# function buildone
# {
# 	# NOTE (Brian) arguments:
# 	#
# 	# 1. command
# 	# 2. build string (identifier)
# 	# 3. build directory
# 
# 	if [ $# -ne 3 ]; then
# 		err "not enough arguments for buildone: $@"
# 		exit 1
# 	fi
# 
# 	bcmd="$1"
# 	bstr="$2"
# 	bdir="$3"
# 
# 	pushd $3
# 
# 	eval $1
# 	RC=$?
# 
# 	if [ $RC -ne 0 ]; then
# 		err "'$1' issue! Exited with code $RC"
# 		exit $RC
# 	fi
# 
# 	addstatestr "$2"
# 
# 	popd
# 
# 	return $RC
# }
# 
# # buildall : builds all of the apps (for water)
# function buildall
# {
# 	# NOTE (Brian) this function reads off of the file setup above in BUILDITEMS
# 	# the format is as follows
# 	#
# 	#   command;state string;dir from root
# 	#
# 	# So let's say I need to run 'make' from my 'build/' directory. You'd configure that like so:
# 	#
# 	#   make;build-part-1;build/
# 	#
# 	# and this function will:
# 	#
# 	# 1. cd to build/
# 	# 2. run the command 'make'
# 	# 3. put the string 'build-part-1' into the BUILDSTATE file, if the command from 2 completes
# 	#
# 	# You should probably know the directory you reference is from the _root_ of your _git_ repo.
# 	#
# 	# Oh, also, you probably want to be careful what command you stuff in here because we sure
# 	# do use eval. Your mileage may vary. To increase build times in non-Makefile friendly source
# 	# trees, we use GNU Parallel to parallelize the execution.
# 
# 	if [ ! -f "$BUILDITEMS" ]; then
# 		err "You need to create the file '$BUILDITEMS' before you can use this command"
# 		exit 1
# 	fi
# 
# 	CURRHASH=$(git rev-parse HEAD)
# 
# 	if [ ! -f "$BUILDSTATE" ] || ( ! hasstatestr $CURRHASH ); then
# 		clearstate
# 		addstatestr "$CURRHASH"
# 	fi
# 
# 	pushd $(gr)
# 
# 	# if [ ! -z "$(which parallel)" ]; then
# 	if [ true ]; then
# 		while IFS= read -r line;
# 		do
# 			[[ "$line" =~ ^\#.* ]] && continue
# 
# 			bcmd=$(echo "$line" | awk -F';' '{print $1}')
# 			bstr=$(echo "$line" | awk -F';' '{print $2}')
# 			bdir=$(echo "$line" | awk -F';' '{print $3}')
# 
# 			[ -z "$bcmd" ] || [ -z "$bstr" ] || [ -z "$bdir" ] && continue
# 
# 			if ( ! hasstatestr "$bstr" ); then
# 				pushd $bdir
# 				time eval $bcmd
# 				if [ $? -ne 0 ]; then
# 					err "'$bcmd' issue! Exited with code $?"
# 					exit 1;
# 				fi
# 				addstatestr "$bstr"
# 				popd
# 			fi
# 
# 		done < "$BUILDITEMS"
# 	else
# 		# unfortunately, this is the only way to export dependencies for parallel
# 		export BUILDSTATE
# 		export -f err
# 		export -f buildone
# 		export -f addstatestr
# 
# 		grep -v "^#" $BUILDITEMS | grep -v -f "$BUILDSTATE" | sed 's/;/\t/g' | \
# 			parallel --halt now,fail=1 --colsep '\t' -n 1 buildone
# 	fi
# 
# 	popd # $(gr)
# }
# 
# # update : updates the database to the most recent version
# function update
# {
# 	${DOTNETEF} database update
# }
# 
# # push : pushes a migration onto the stack
# function push
# {
# 	${DOTNETEF} migrations add $1
# }
# 
# # pop : removes the migration on top of the stack
# function pop
# {
# 	${DOTNETEF} migrations remove --force
# }
# 
# # mostrecent : opens the most recent migration
# function mostrecent
# {
# 	$PAGER Migrations/$(ls -lc Migrations/ | tail -n3 | head -n1 | grep -oE '[^ ]+$')
# }
# 
# # listmigrations : lists the 5 most recent migrations
# function listmigrations
# {
# 	ls -lc Migrations/ | grep -v "Designer.cs$" | grep -v "DbContextModelSnapshot.cs$" | tail -n7
# }
# 
# # resetcontainer : resets the container
# function resetcontainer
# {
# 	# NOTE (brian)
# 	# $1 - name
# 	# $2 - port string (remapping)
# 	# $3 - address(?)
# 
# 	docker stop "$1"
# 	docker rm "$1"
# 	docker run -u 0:0 -p "$2" -v $HOME/shared:/shared -d --name "$1" "$3"
# }
# 
# # newdb : starts up a new database
# function newdb
# {
# 	# NOTE (Brian) input file format
# 	#
# 	# container_name;portremapping;container_remote
# 
# 	if [ ! -f "$CONTAINERFILE" ]; then
# 		err "You need to create the file '$CONTAINERFILE' before you can use this command"
# 		exit 1
# 	fi
# 
# 	while IFS= read -r line;
# 	do
# 		[[ "$line" =~ ^\#.* ]] && continue
# 
# 		cname=$(echo "$line" | awk -F';' '{print $1}')
# 		cport=$(echo "$line" | awk -F';' '{print $2}')
# 		cremote=$(echo "$line" | awk -F';' '{print $3}')
# 
# 		# we skip over lines that aren't formatted properly
# 		# if you have a funky issue, my guess is it's here
# 		[ -z "$cname" ] && continue
# 		[ -z "$cport" ] && continue
# 		[ -z "$cremote" ] && continue
# 
# 		resetcontainer "$cname" "$cport" "$cremote"
# 	done < "$CONTAINERFILE"
# }
# 
# # indexify : create an index.ts file in this directory, with every .ts file below
# function indexify
# {
# 	[ -t 1 ] && INDEXFILE="index.ts" || INDEXFILE="/dev/stdout"
# 	[ -z "$1" ] && DIR="." || DIR="$1"
# 
# 	find $DIR -iname "*.ts" -and -not -iname "*.spec.ts"| \
# 		sort | \
# 		sed 's/\.ts$//' | \
# 		awk '{print "export * from \"" $1 "\";"}' > $INDEXFILE
# }
# 
# # forktree : creates a worktree that forks the current branch to the selected dir
# function forktree
# {
# 	# USAGE : workscript forktree <dir>
# 
# 	DIR=$(realpath $1)
# 
# 	git worktree add $DIR HEAD
# 	mkdir -pv "$DIR/Angular/node_modules"
# 	parallel -j24 cp -r {} "$DIR/Angular/node_modules/" ::: Angular/node_modules/*
# 
# 	echo "forktree created at " $(git worktree list | grep "$DIR" | awk '{print $1'})
# }
# 
# if [ "$#" -eq 0 ]; then
# 	usage
# fi
# 
# while (( "$#" ))
# do
# 	cmd="$1"
# 	arg="$2"
# 
# 	case "$cmd" in
# 		"mkcontainer")
# 			mkcontainer $arg "$3"
# 			shift
# 			shift
# 		;;
# 		"push")
# 			push $arg
# 			shift
# 		;;
# 		"pop")
# 			pop
# 		;;
# 		"update")
# 			update
# 		;;
# 		"mostrecent")
# 			mostrecent
# 		;;
# 		"listmigrations")
# 			listmigrations
# 		;;
# 		"buildall")
# 			buildall
# 		;;
# 		"trigger")
# 			trigger
# 		;;
# 		"reap")
# 			reap
# 		;;
# 		"indexify")
# 			indexify $arg
# 			shift
# 		;;
# 		"azlogin")
# 			azlogin
# 		;;
# 		"newdb")
# 			newdb
# 		;;
# 		"forktree")
# 			forktree $arg
# 			shift
# 		;;
# 		*)
# 			usage
# 		;;
# 	esac
# 
# 	shift
# done
# 
